{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This is a my personal repository of notes; mostly related to computer science. Since books contain a lot of unnecessary knowledge in-between important stuff, it's crucial to have a persisent container of all the important bits of understanding you made from the book. Personally I gather my knowledge from multiple sources on one topic, so it's even crucial for me to have a repository like this.</p>"},{"location":"c/","title":"C","text":""},{"location":"c/#pointers","title":"Pointers","text":""},{"location":"c/#reference-operator","title":"Reference Operator","text":"<p>In expressions <code>*</code> derefences a pointer, (and does other jobs as per grammar).</p> <p>In declarations <code>*</code> marks a variable as a pointer.</p> <p><pre><code>void somefunc(int a)\n</code></pre> Creates a copy of <code>a</code></p> <p><pre><code>void somefunc(int *a)\n</code></pre> Takes a pointer to an <code>int</code> as input. But makes a copy of the pointer.</p> <p>Important</p> <p>The rule of declaration in C is, you declare it the way you use it.</p> <p>Example</p> <p><code>int *p</code> means you need <code>*p</code> (a pointer) to get a <code>int</code></p> <p><code>int **p</code> means you need <code>**p</code> (a pointer to a pointer) to get a <code>int</code></p> <p><code>int ***p</code> means you need <code>***p</code> (a pointer to a pointer to a pointer) to get a <code>int</code></p> ExampleOutput Little Examples of Pointers<pre><code>#include &lt;stdio.h&gt;\n\nvoid printppp(int ***ptr) {\n    printf(\"pointer to pointer to pointer: %d\\n\", ***ptr);\n}\n\nint main(void) {\n    // i has the value 1\n    int i = 1;\n    // k is a special variable where it just points to i\n    int *p = &amp;i;\n    // p is a special variable where it just points to k\n    int **pp = &amp;p;\n    // ppp is a special variable where it just points to pp\n    int ***ppp = &amp;pp;\n\n    printf(\"value: %d\\n\", i);\n    printf(\"pointer: %d\\n\", *p); \n    // since p points to k, which points to i, we need to deference p twice\n    printf(\"pointer to pointer: %d\\n\", **pp); // or *(*p)\n    // since the function accepts a pointer, we don't deference it\n    printppp(ppp);\n    return 0;\n}\n</code></pre> <pre><code>value: 1\npointer: 1\npointer to pointer: 1\npointer to pointer to pointer: 1\n</code></pre>"},{"location":"c/#address-operator","title":"Address Operator","text":"<p>In expressions <code>&amp;</code> gets you the address of a pointer.</p>"},{"location":"c/#constant-pointers","title":"Constant Pointers","text":"<p>Consider the following example, <pre><code>const int *ptr = &amp;a;\n</code></pre> Here, <code>ptr</code> points to <code>a</code> which is of <code>const int</code> type. What that means is that the value of <code>a</code> is read-only; however that does not mean the pointer is read-only: the reference that <code>ptr</code> holds can be changed at any time, <pre><code>ptr = &amp;b;\n</code></pre> ... Is perfectly legal.</p> <p>However if a constant pointer is declared, its value cannot be changed: <pre><code>const int *const ptr = &amp;a;\n</code></pre></p> Example IOutputExample IIOutput <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    const int a = 69;\n    const int b = 420;\n    const int *ptr = &amp;a;\n\n    printf(\"ptr: %d\\n\", *ptr);\n    ptr = &amp;b;\n    printf(\"ptr: %d\\n\", *ptr);\n\n    return 0;\n}\n</code></pre> <pre><code>./main\nptr: 69\nptr: 420\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    const int a = 69;\n    const int b = 420;\n    const int *const ptr = &amp;a;\n\n    printf(\"ptr: %d\\n\", *ptr);\n    ptr = &amp;b;\n\n    return 0;\n}\n</code></pre> <pre><code>main.c:9:6: error: cannot assign to variable 'ptr' with const-qualified type 'const int *const'\n    9 |         ptr = &amp;b;\n      |         ~~~ ^\nmain.c:6:19: note: variable 'ptr' declared const here\n    6 |         const int *const ptr = &amp;a;\n      |         ~~~~~~~~~~~~~~~~~^~~~~~~~\n1 error generated.\n</code></pre> <p>As you can see, a constant pointer's value cannot be changed.</p>"},{"location":"c/#arithmetic","title":"Arithmetic","text":"<p>Important</p> <p>When you increment a pointer of any type by <code>n</code>, it increments the pointer by the size of its type times <code>n</code>.</p>"},{"location":"c/#simple","title":"Simple","text":"Example IOutputExample IIOutput <pre><code>#include &lt;stdio.h&gt;\n#include &lt;inttypes.h&gt;\n\nint main(void) {\n    int a = 69;\n    int *p = &amp;a;\n\n    printf(\"sizeof(int):  %ld\\n\", sizeof(int));\n    printf(\"Address of p: %lu\\n\", (uintptr_t)p);\n\n    long unsigned n1 = (uintptr_t)++p;\n    long unsigned n2 = (uintptr_t)++p;\n\n    printf(\"n1:           %lu\\n\", n1);\n    printf(\"n2:           %lu\\n\", n2);\n    printf(\"Difference:   %lu, %lu\\n\", n2 - n1, (uintptr_t)p - n1);\n    return 0;\n}\n</code></pre> <pre><code>./main\nsizeof(int):  4\nAddress of p: 140721500910884\nn1:           140721500910888\nn2:           140721500910892\nDifference:   4, 4\n</code></pre> <pre><code>#include &lt;inttypes.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    const int M = 3;\n    const int N = 6;\n\n    int a = 69;\n    int *p = &amp;a;\n\n    printf(\"sizeof(int):  %ld\\n\", sizeof(int));\n    printf(\"Address of p: %lu\\n\", (uintptr_t)p);\n\n    long unsigned n1 = (uintptr_t)(p + M);\n    long unsigned n2 = (uintptr_t)(p + N);\n\n    printf(\"n1:           %lu\\n\", n1);\n    printf(\"n2:           %lu\\n\", n2);\n    printf(\"Difference:   %lu, %lu\\n\", n2 - n1, n2 - (uintptr_t)p);\n    printf(\"%d * %d = %d, %d * %d = %d\\n\", sizeof(int), M, sizeof(int) * M, sizeof(int), N, sizeof(int) * N);\n    return 0;\n}\n</code></pre> <pre><code>./main\nsizeof(int):  4\nAddress of p: 140721262450916\nn1:           140721262450928\nn2:           140721262450940\nDifference:   12, 24\n4 * 3 = 12, 4 * 6 = 24\n</code></pre>"},{"location":"c/#arrays","title":"Arrays","text":"<p>Since arrays are contiguous in memory, you can do quite a bit of sophisticated array manipulation using pointer arithmetic.</p> Example IOutputExample IIOutput <pre><code>#include &lt;stdio.h&gt;\n\nvoid printp(int *i) {\n    printf(\"%d\\n\", *i);\n}\n\n\nint main(void)\n{\n    int t[5] = {1,2,3,4,5};\n    int *d = &amp;t[0];\n    for (int i = 0; i &lt; 5; i++) {\n        printp(d+i);\n    }\n    return 0;\n}\n</code></pre> <pre><code>./main\n1\n2\n3\n4\n5\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n\nvoid printp(int i) {\n    printf(\"%d\\n\", i);\n}\n\n\nint main(void)\n{\n    int t[5] = {1,2,3,4,5};\n    int *d = &amp;t[0];\n    for (int i = 0; i &lt; 5; i++) {\n        printp(*(d++));\n    }\n    return 0;\n}\n</code></pre> <pre><code>./main\n1\n2\n3\n4\n5\n</code></pre> <p>Note</p> <p><code>*(p+n)</code> is equivalent to <code>p[n]</code>. The latter is a syntactic sugar for the former.</p> Example IOutputExample IIOutputExample IIIOutput <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int arr[] = {1,2,3,4};\n    for (int i = 0; i &lt; 4; i++) {\n        printf(\"%p %d\\n\", arr+i, *(arr+i));\n    }\n\n    return 0;\n}\n</code></pre> <pre><code>./main\n0x7ffd9a93ad90 1\n0x7ffd9a93ad94 2\n0x7ffd9a93ad98 3\n0x7ffd9a93ad9c 4\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char text[] = \"Test\";\n    // char text[] = {'T', 'e', 's', 't', '\\0'};\n    // char text[4] = {'T', 'e', 's', 't', '\\0'};\n    for (int i = 0; i &lt; (sizeof(text) / sizeof(char) - 1); i++) {\n        printf(\"%c\", *(text+i));\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n</code></pre> <pre><code>./main\nTest\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int i = 69;\n    int* t[1][1] = {{&amp;i}};\n    printf(\"%d\\n\", ***t); \n\n    return 0;\n}\n</code></pre> <pre><code>./main\n69\n</code></pre>"},{"location":"c/#pointers-in-structs","title":"Pointers in Structs","text":"Example IOutput <p><pre><code>#include &lt;stdio.h&gt;\n\ntypedef struct {\n    const int height;\n    const int width;\n    const char *name[50];\n} Image;\n\nvoid print_image_ptr(const Image *image) {\n    printf(\"height: %d, width: %d, name: %s\\n\", image-&gt;height, image-&gt;width, *image-&gt;name);\n   }\n\nvoid print_image(const Image image) {\n    printf(\"height: %d, width: %d, name: %s\\n\", image.height, image.width, *image.name);\n}\n\nint main() {\n    const char name[50] = \"Hello!\";\n    Image image = {1080, 720, name}; // (1)\n    Image *image_ptr = &amp;image;\n\n    printf(\"height: %d, width: %d, name: %s\\n\", image.height, image.width, *image.name);\n    printf(\"height: %d, width: %d, name: %s\\n\", image_ptr-&gt;height, image_ptr-&gt;width, *image_ptr-&gt;name);\n\n    print_image_ptr(image_ptr);\n    print_image(image);\n\n    return 0;\n}\n</code></pre></p> <ol> <li>Since <code>name</code> is an array, when you pass it to the constructor, the compiler passes a pointer to the first element of the array. If the struct wasn't accepting a pointer to an array of array of 50 <code>char</code>s, but instead accepted a pointer to an array of 50 <code>char</code>s then you would accept <code>const char* image</code> in the struct definition, for the same reason I just stated.</li> </ol> <pre><code>./main\nheight: 1080, width: 720, name: Hello!\nheight: 1080, width: 720, name: Hello!\nheight: 1080, width: 720, name: Hello!\nheight: 1080, width: 720, name: Hello!\n</code></pre>"},{"location":"c/#function-pointers","title":"Function Pointers","text":"<p>You declare function pointers with the following syntax: <pre><code>&lt;return type&gt; (*&lt;pointer_name&gt;)(&lt;argument type&gt;, ...);\n</code></pre></p> Example IOutput <pre><code>#include &lt;stdio.h&gt;\n\nint add(const int a, const int b) {\n    return a + b;\n}\n\nint main(void) {\n    int (*ptr_name)(const int, const int);\n\n    ptr_name = add;\n    ptr_name = &amp;add;\n    ptr_name = ******************add;\n\n    printf(\"Sum of 1 + 2 is %d\\n\", (*ptr_name)(1, 2));\n\n    return 0;\n}\n</code></pre> <pre><code>./main\nSum of 1 + 2 is 3\n</code></pre>"},{"location":"c/#dynamic-memory","title":"Dynamic Memory","text":"<p><code>malloc</code>, <code>calloc</code>, <code>realloc</code>, <code>free</code>, are available in <code>stdlib.h</code>.</p> <pre><code>void *calloc(size_t nmemb, size_t size);\nvoid *malloc(size_t size);\nvoid *realloc(void *ptr, size_t size);\nvoid free(void *ptr);\n</code></pre> <ul> <li> <p><code>calloc()</code> allocates memory for an array of <code>nmemb</code> elements of size bytes each and returns a pointer to the allo- cated memory. The memory is set to zero.</p> </li> <li> <p><code>malloc()</code> allocates size bytes and returns a pointer to the allocated memory. The memory is not cleared.</p> </li> <li> <p><code>free()</code> frees the memory space pointed to by <code>ptr</code>, which must have been returned by a previous call to <code>malloc()</code>, <code>calloc()</code> or <code>realloc()</code>. Otherwise, or if <code>free(ptr)</code> has already been called before, undefined behaviour occurs. If <code>ptr</code> is <code>NULL</code>, no operation is performed.</p> </li> <li> <p><code>realloc()</code> changes the size of the memory block pointed to by <code>ptr</code> to size bytes. The contents will be unchanged to the minimum of the old and new sizes; newly allocated memory will be uninitialized. If <code>ptr</code> is <code>NULL</code>, the call is equivalent to <code>malloc(size)</code>; if size is equal to zero, the call is equivalent to <code>free(ptr)</code>. Unless <code>ptr</code> is <code>NULL</code>, it must have been returned by an earlier call to <code>malloc()</code>, <code>calloc()</code> or <code>realloc()</code>.</p> </li> </ul> Example IOutput <p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid print_pointers(char *str, int size) {\n    for (int i = 0; i &lt; size; i++)\n        printf(\"pointer: %s\\n\", str[i] == NULL ? \"allocated\" : \"not allocated\");\n}\n\nint main(void) {\n    const int SIZE;\n\n    printf(\"[PROMPT] Enter text size in bytes: \");\n    scanf(\"%d\", (int *) &amp;SIZE);\n    printf(\"[INFO] Entered bytes: %d\\n\", SIZE);\n\n    char *str = (char *)malloc(SIZE * sizeof(char));\n\n    print_pointers(str, SIZE);\n\n    free(str);\n    printf(\"[INFO] Memory free'd.\\n\");\n\n    print_pointers(str, SIZE);\n\n    return 0;\n}\n</code></pre> The first call to <code>print_pointer</code> will only print \"allocated\", but with the second call the behaviour is undefined.</p> <pre><code>./main\n[PROMPT] Enter text size in bytes: 5\n[INFO] Entered bytes: 5\npointer: 0\npointer: 0\npointer: 0\npointer: 0\npointer: 0\n[INFO] Memory free'd.\npointer: -92\npointer: 17\npointer: 0\npointer: 0\npointer: 0   \n</code></pre> <p>Important</p> <p><pre><code>int a[N];\n</code></pre> <pre><code>int *p = (int) calloc(N * sizeof(int));\n</code></pre> Here, <code>p</code> and <code>a</code> are not equivalent. The first example requests a contiguous block of memory of size <code>N * sizeof(int)</code> then names it <code>a</code>, however <code>a</code> is not a pointer, it is an array. But the second example only assigns a reference to a contiguous block of memory to a pointer (<code>p</code>). When you pass <code>a</code> to a function the compiler instead passes a pointer to the first element of the array, but when you pass <code>p</code> to a function, it just passes itself. If a function happens to change the reference in the pointer <code>p</code>, the contiguous block of memory that it holds reference to is now forever lost. But in case of <code>a</code>, the original array is never lost since <code>a</code> is not a pointer by itself, it is the compiler that does the magic when you pass the array <code>a</code> to a function.</p> <p>Tip</p> <p>Please go through C-FAQ 6.2 and C-FAQ 6.3.</p> <p>Important</p> <p>Calling <code>free()</code> on a pointer doesn't change it, only marks memory as free. Your pointer will still point to the same location which will contain the same value, but that value can now get overwritten at any time, so you should never use a pointer after it is <code>free</code>'d. To ensure that, it is a good idea to always set the pointer to <code>NULL</code> after <code>free</code>'ing it.</p>"},{"location":"c/#memory-leaks","title":"Memory Leaks","text":"<p>Consider the following example, <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n\nint main(void) {\n    int N = 30;\n    int A[N];\n\n    for (int i = 0; i &lt; N; i++)\n        A[i] = random();\n\n    int *B = malloc(2 * N);\n    B = A;\n\n    return 0;\n}\n</code></pre> Here we declare a static array of <code>N=30</code>, then we assign random values to the pointers.  We then allocate <code>N*2</code> bytes to <code>B</code> pointer. We then overwrite the reference value in  variable <code>B</code> with <code>A</code>'s reference value. Now the dynamic memory block's reference we got  from <code>malloc</code> at line 12 is lost. This loss of bytes is termed as a memory leak.</p> <p>Tip</p> <p>See this forum post to find memory leaks in your program.</p>"},{"location":"c/#copying-memory","title":"Copying Memory","text":"<ul> <li>The  <code>memcpy()</code>  function  copies <code>n</code> bytes from memory area <code>src</code> to memory area <code>dest</code>.  The memory areas must not overlap.</li> <li>The  <code>memmove()</code>  function  copies <code>n</code> bytes from memory area <code>src</code> to memory area <code>dest</code>. The memory areas may overlap: copying takes place as though the bytes in <code>src</code> are first copied into a temporary array that does not overlap <code>src</code> or <code>dest</code>, and the bytes are then copied from the temporary array to <code>dest</code>.  <pre><code>void *memcpy(void *dest, const void *src, size_t n);\nvoid *memmove(void *dest, const void *src, size_t n);\n</code></pre> <code>memcpy()</code> and <code>memmove()</code> are declared in <code>string.h</code>. <code>memcpy()</code> does not support overlapping  but <code>memmove()</code> does. That's the difference between the two. Otherwise they are equivalent. Look and understand the example below and then study the output.</li> </ul> Example IOutput <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nvoid print_arr(const int *arr, const int size, const int h_at) {\n    printf(\"{\");\n    for (int i = 0; i &lt; size; i++) {\n        if (h_at == i) printf(\"[\");\n        printf(\"%d\", arr[i]);\n        if (h_at == i) printf(\"]\");\n        if (i &lt; (size - 1)) printf(\", \");\n    }\n    printf(\"}\\n\");\n}\n\nint main(void) {\n    int A[] = {1, 2, 3, 4};\n    int B[] = {5, 6, 7, 8};\n\n    const int A_SIZE = sizeof(A) / sizeof(int);\n    const int B_SIZE = sizeof(B) / sizeof(int);\n\n    int *con_arr = calloc(A_SIZE + B_SIZE, sizeof(int));\n    memcpy(con_arr, A, A_SIZE * sizeof(int));\n    memcpy(con_arr + A_SIZE, B, B_SIZE * sizeof(int));\n\n    int *con_arr_copy = calloc(A_SIZE + B_SIZE, sizeof(int));\n    memcpy(con_arr_copy, con_arr, (A_SIZE + B_SIZE) * sizeof(int));\n\n    printf(\"Original:    \");\n    print_arr(con_arr, A_SIZE + B_SIZE, -1);\n    printf(\"\\n\");\n\n    for (int offset = 0; offset &lt;= A_SIZE; offset++) {\n        memcpy(con_arr + A_SIZE - offset, con_arr, A_SIZE * sizeof(int));\n        printf(\"[%d] memcpy:  \", offset);\n        print_arr(con_arr, A_SIZE + B_SIZE, A_SIZE - offset);\n        memcpy(con_arr, con_arr_copy, sizeof(con_arr) * sizeof(int));\n    }\n\n    printf(\"\\n\");\n\n    for (int offset = 0; offset &lt;= A_SIZE; offset++) {\n        memmove(con_arr + A_SIZE - offset, con_arr, A_SIZE * sizeof(int));\n        printf(\"[%d] memmove: \", offset);\n        print_arr(con_arr, A_SIZE + B_SIZE, A_SIZE - offset);\n        memcpy(con_arr, con_arr_copy, sizeof(con_arr) * sizeof(int));\n    }\n\n    return 0;\n}\n</code></pre> <pre><code>./main\nOriginal:    {1, 2, 3, 4, 5, 6, 7, 8}\n\n[0] memcpy:  {1, 2, 3, 4, [1], 2, 3, 4}\n[1] memcpy:  {1, 2, 3, [1], 2, 3, 1, 8}\n[2] memcpy:  {1, 2, [1], 2, 1, 2, 7, 8}\n[3] memcpy:  {1, [1], 2, 2, 4, 6, 7, 8}\n[4] memcpy:  {[1], 2, 3, 4, 5, 6, 7, 8}\n\n[0] memmove: {1, 2, 3, 4, [1], 2, 3, 4}\n[1] memmove: {1, 2, 3, [1], 2, 3, 4, 8}\n[2] memmove: {1, 2, [1], 2, 3, 4, 7, 8}\n[3] memmove: {1, [1], 2, 3, 4, 6, 7, 8}\n[4] memmove: {[1], 2, 3, 4, 5, 6, 7, 8}\n</code></pre>"},{"location":"c/#stack-and-heap","title":"Stack and Heap","text":""},{"location":"c/#stack","title":"Stack","text":"Memory organization of a typical program in     MIPS <p>Areas of memory of a program are called segments: the text segment, the stack segment, and the heap segment.</p> <ul> <li>The text (or code) segment contains the compiled code of the executable.</li> <li>The stack segment is used to store your local variables and is used for passing arguments to the functions along with the return address of the instruction which is to be executed after the function call is over. When a new stack frame needs to be added (as a result of a newly called function), the stack grows downward.</li> <li>The heap segment is used when program allocate memory at runtime using <code>calloc</code> and <code>malloc</code> function, then memory gets allocated in heap. When some more memory need to be allocated using <code>calloc</code> and <code>malloc</code> function, heap grows upward as shown in above diagram.</li> </ul> <p>The stack and heap are traditionally located at opposite ends of the process\u2019s virtual address space. The stack grows automatically when accessed, up to a size set by the kernel (which can be adjusted with <code>setrlimit(RLIMIT_STACK, ...)</code> on UNIX systems). The heap grows when the memory allocator invokes the <code>brk()</code> or <code>sbrk()</code> system call, mapping more pages of physical memory into the process\u2019s virtual address space.</p> <p>Implementation of both the stack and heap is usually down to the runtime/OS. Often games and other applications that are performance critical create their own memory solutions that grab a large chunk of memory from the heap and then dish it out internally to avoid relying on the OS for memory</p> <p>Stacks in computing architectures are regions of memory where data is added or removed in a last-in-first-out manner. In most modern computer systems, each thread has a reserved region of memory referred to as its stack. When a function executes, it may add some of its state data to the top of the stack; when the function exits it is responsible for removing that data from the stack. At a minimum, a thread\u2019s stack is used to store the location of function calls in order to allow return statements to return to the correct location, but programmers may further choose to explicitly use the stack. If a region of memory lies on the thread\u2019s stack, that memory is said to have been allocated on the stack.</p> <p>Because the data is added and removed in a last-in-first-out manner, stack allocation is very simple and typically faster than heap-based memory allocation (also known as dynamic memory allocation). Another feature is that memory on the stack is automatically, and very efficiently, reclaimed when the function exits.</p> <p>Important</p> <p>Do not return pointers to static variables from a function's scope. Static variables are automatically <code>free</code>'d outside the function's scope.</p> <p>Tip</p> <p>For a simplified introduction to stack and heap read this and for more detailed introduction read this. </p> <ul> <li>The OS allocates the stack for each system-level thread when the thread is created. Typically the OS is called by the language runtime to allocate the heap for the application.</li> <li>The stack is attached to a thread, so when the thread exits the stack is reclaimed. The heap is typically allocated at application startup by the runtime, and is reclaimed when the application (technically process) exits.</li> <li>The size of the stack is set when a thread is created.</li> <li>You would use the stack if you know exactly how much data you need to allocate before compile time and it is not too big.</li> <li>The stack is faster because the access pattern makes it trivial to allocate memory from it, while the heap has much more complex bookkeeping involved in an allocation or free. Also, each byte in the stack tends to be reused very frequently which means it tends to be mapped to the processor\u2019s cache, making it very fast.</li> <li>Variables created on the stack will go out of scope and automatically deallocate.</li> <li>Much faster to allocate in comparison to variables on the heap.</li> <li>Implemented with an actual stack data structure.</li> <li>Stores local data, return addresses, used for parameter passing</li> <li>Can have a stack overflow when too much of the stack is used. (mostly from inifinite or too much recursion and very large allocations)</li> <li>Data created on the stack can be used without pointers.</li> <li>In C you can get the benefit of variable length allocation through the use of <code>alloca()</code>, which allocates on the stack, as opposed to alloc, which allocates on the heap. This memory won\u2019t survive your return statement, but it\u2019s useful for a scratch buffer.</li> </ul>"},{"location":"c/#stack-overflow","title":"Stack Overflow","text":"<p>Variables created on the stack are always contiguous with each other, writing out of bounds can change the value of another variable.</p> An Instance of Stack OverflowBeforeAfter <p><pre><code>#include &lt;string.h&gt;\n\n\nvoid foo (char *bar) {\n    char c[12];\n    strcpy(c, bar); // no bounds checking...\n}\n\nint main (int argc, char **argv) {\n    foo(argv[1]);\n}\n</code></pre> When an argument larger than 11 bytes is suplied on the command line <code>foo()</code> overwrites local stack data, the saved frame pointer, and most importantly, the return address. When <code>foo()</code> returns it pops the return address off the stack and jumps to that address (i.e. starts executing instructions from that address). In the example above, the attacker has overwritten the return address with a pointer to the stack buffer char <code>c[12]</code>, which now contains attacker supplied data. In an actual stack buffer overflow exploit the string of \u201dA\u201d\u2019s would be replaced with shellcode suitable to the platform.</p> <p></p> <p></p>"},{"location":"c/#heap","title":"Heap","text":"<p>The heap contains a linked list of used and free blocks. New allocations on the heap (by  <code>new</code> (C++) or <code>malloc()</code>) are satisfied by creating a suitable block from one of the free blocks. This requires  updating list of blocks on the heap. This meta information about the blocks on the heap is also stored on the heap  often in a small area just in front of every block.</p> <ul> <li>The size of the heap is set on application startup, but can grow as space is needed (the allocator requests more memory from the operating system).</li> <li>Stored in computer RAM like the stack.</li> <li>Variables on the heap must be destroyed manually and never fall out of scope. The data is freed with delete, delete[] or free</li> <li>Slower to allocate in comparison to variables on the stack.</li> <li>Used on demand to allocate a block of data for use by the program.</li> <li>Can have fragmentation when there are a lot of allocations and deallocations</li> <li>Can have allocation failures if too big of a buffer is requested to be allocated.</li> <li>You would use the heap if you don\u2019t know exactly how much data you will need at runtime or if you need to allocate a lot of data.</li> <li>Responsible for memory leaks.</li> </ul>"},{"location":"c/#heap-overflow","title":"Heap Overflow","text":"<p>A heap overflow, heap overrun, or heap smashing is a type of buffer overflow that occurs in the heap data area. Heap overflows are exploitable in a different manner to that of stack-based overflows. Memory on the heap is dynamically allocated at runtime and typically contains program data. Exploitation is performed by corrupting this data in specific ways to cause the application to overwrite internal structures such as linked list pointers. The canonical heap overflow technique overwrites dynamic memory allocation linkage (such as <code>malloc</code> metadata) and uses the resulting pointer exchange to overwrite a program function pointer.</p> <p>Tip</p> <p>Read more here.</p>"},{"location":"c/#compilation","title":"Compilation","text":"<p>Tip</p> <p>Refer to this and this for more in-depth information.</p> <p>Libraries are archives of object files. In a sense object files are simply compiled byte code of your source code that is yet to be linked. Before linking your source code went through several stages, those stages as part of their process ensure your linker can do its job correctly and efficiently. Before linking your compiler only makes reference to things like external functions like <code>printf</code>. A linker's job is to actually look for them and... Link them to your program.</p> <p>Once the linker is done with its job, it outputs an executable that you can run on a specific CPU architecture.</p> <p>Note</p> <p>Inclusion of source code into another file using <code>#include</code>, <code>#define</code>, etc., and making sure it actually exists is not the job of the linker. That's the job of the preprocessor. E.g., if your source code is missing the definition of a variable, the error is from the preprocessor, not the linker.</p> <p><pre><code>gcc -c main.c\n</code></pre> Output an object file <code>main.o</code>.</p> <p><pre><code>gcc -S main.c\n</code></pre> Output the assembly file <code>main.s</code>.</p> <p><pre><code>gcc -o main.c\n</code></pre> Output an executable <code>main</code>.</p>"},{"location":"c/#libraries","title":"Libraries","text":"<p>As explained, libraries are archives of object files.</p>"},{"location":"c/#making-and-using-static-libraries","title":"Making and Using Static Libraries","text":"<p>For a bare-minimum example, you will need two files, <code>test.h</code> and <code>test.o</code>, to create the static library. <code>test.h</code> is needed for the program that is to make use of your library; without it the preprocessor will not be able to make sense of your use of symbols that are undeclared from the preprocessor's perspective (not the linker).</p> <p>To create the static library we will use <code>ar</code> that is available on Unix and Unix-like systems. This command is simply an archiver.</p> <pre><code>ar -csr libtest.a test.o\n</code></pre> <ul> <li><code>-c</code> create the library if it doesn't exist.</li> <li><code>-s</code> generate an index.</li> <li><code>-r</code> replace anything of the same name that is already in the library.</li> </ul> <p>Tip</p> <p>You can view the manpage for more information, <code>man ar</code>.</p> <p>Tip</p> <p>You can view the filenames of the object files that are in an archive with <code>ar -t libname.[a,so]</code>.</p> <p>Note</p> <p><code>gcc</code> lets you add other directories onto the linker's search path by defining the environment variable <code>LIBRARY_PATH</code>.  Just put a colon-separated list of directories into this variable, and <code>gcc</code> will add these directories to the standard list of places where it looks for static libraries.</p> <p>A library must be prefixed with <code>lib</code>. A static library must end with <code>.a</code> extension. Between <code>lib</code> and <code>.a</code> is the name of your library.</p> <pre><code>gcc -o main -L. -ltest main.c\n</code></pre> <ul> <li><code>-L</code> tells <code>gcc</code> to look in an additional directory when trying to find libraries.</li> <li><code>-I</code> tells <code>gcc</code> to look in an additional directory when trying to find <code>include</code> files.</li> <li><code>-l</code> says to link the program with the following library. <code>test</code> is the name of the library.</li> </ul> test.htest.cmain.c <pre><code>int add(const int a, const int b);\n</code></pre> <pre><code>#include \"test.h\"\n\nint add(const int a, const int b) {\n    return a + b;\n}\n</code></pre> <p><pre><code>#include &lt;stdio.h&gt;\n#include \"test.h\"\n\nint main() {\n    printf(\"%d\\n\", add(1, 2));\n    return 0;\n}\n</code></pre> Output of main.c<pre><code>./main\n3\n</code></pre></p>"},{"location":"c/#making-and-using-dynamic-libraries","title":"Making and Using Dynamic Libraries","text":"<p>Please read the Creating and Using Dynamic Libraries section from here.</p>"},{"location":"c/#type-qualifiers","title":"Type Qualifiers","text":"<p>Tip</p> <p>Refer to this article  for more information on <code>const</code> and <code>volatile</code>.</p>"},{"location":"c/#const-c89","title":"<code>const</code> (C89)","text":"<p><code>const</code> is used with a datatype declaration or definition to specify an unchanging value.</p> <pre><code>const int five = 5;\nconst double pi = 3.141593;\n</code></pre> <p><code>const</code> objects may not be changed.</p> Illegal Uses of Const<pre><code>const int five = 5;\nconst double pi = 3.141593;\n\npi = 3.2;\nfive = 6;\n</code></pre>"},{"location":"c/#volatile-c89","title":"<code>volatile</code> (C89)","text":"<p><code>volatile</code> specifies a variable whose value may be changed by processes outside the current program</p> Example I <p>Volatile Object That Might Be a Buffer Used to Exchange Data With an External Device<pre><code>int check_iobuf(void) {\n    volatile int iobuf;\n    int val;\n\n    while (iobuf == 0) {\n    }\n    val = iobuf;\n    iobuf = 0;\n    return(val);\n}\n</code></pre> if <code>iobuf</code> had not been declared <code>volatile</code>, the compiler would notice that nothing happens inside the loop and thus eliminate the loop <code>const</code> and <code>volatile</code> can be used together.</p> <p>Note</p> <p>An input-only buffer for an external device could be declared as <code>const volatile</code> (or <code>volatile const</code>, order is not important) to make sure the compiler knows that the variable should not be changed (because it is input-only) and that its value may be altered by processes other than the current program</p>"},{"location":"c/#restrict-c99","title":"<code>restrict</code> (C99)","text":"<p><code>restrict</code> keyword hints the compiler no other pointer can be used to point to the  object that a pointer with this type qualifier points to.</p> <p>Tip</p> <p>Read this page for more inforamtion.</p>"},{"location":"c/#_atomic-c11","title":"<code>_Atomic</code> (C11)","text":"<p>Their purpose is to ensure race-free access to variables that are shared between different threads. Without atomic qualification, the state of a shared variable would be undefined if two threads access it concurrently.</p> <p>Note</p> <p>For more information please refer to this answer.</p> Example I Atomic Constant Integer Variable Declaration<pre><code>_Atomic const int name;\n</code></pre> <p>Tip</p> <p>Read about data races here.</p>"},{"location":"c/#storage-classes","title":"Storage Classes","text":"<p>Tip</p> <p>Refer to this page for more information. You can also find more information on this thread.</p>"},{"location":"c/#auto","title":"<code>auto</code>","text":"<p><code>auto</code> is the default storage class for all local variables. Automatic, or local, or stack variables only last for its scope's lifetime.</p> Example IOutput <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint* ret_ptr(void) {\n    auto int local_var = 69;\n    int *local_var_ptr = &amp;local_var;\n\n    printf(\"ptr: %d\\n\", *local_var_ptr);\n\n    return local_var_ptr;\n}\n\nint main(void) {\n    int *local_var_ptr = ret_ptr();\n\n    int *ints = alloca(sizeof(int) * 5);\n    for (int i = 0; i &lt; 5; i++) {\n        ints[i] = random();\n    }\n\n    printf(\"ptr: %d\\n\", *local_var_ptr);\n\n    return 0;\n}\n</code></pre> <pre><code>./main\nptr: 69\nptr: 1957747793\n</code></pre>"},{"location":"c/#static-internal-linkage","title":"<code>static</code> (Internal Linkage)","text":"<p>The <code>static</code> storage class instructs the compiler to keep a local variable in existence during the life-time of the program instead of creating and destroying it each time it comes into and goes out of scope. Therefore, making local variables <code>static</code> allows them to maintain their values between function calls.</p> <p>Note</p> <p><code>static</code> variables are by default initiliazed to zero. Non-static variables may also be zero but you are entirely dependent on the compiler's implementation (undefined behavior).</p> <p>Note</p> <p>When <code>static</code> is explicitly used for declaring a global variable (or function), it causes that variable's scope to be restricted to the file in which it is declared.</p> Example 1OutputExample IIOutput <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint* ret_ptr(void) {\n    static int local_var = 69;\n    int *local_var_ptr = &amp;local_var;\n\n    printf(\"ptr: %d\\n\", *local_var_ptr);\n\n    return local_var_ptr;\n}\n\nint main(void) {\n    int *local_var_ptr = ret_ptr();\n\n    int *ints = alloca(sizeof(int) * 100);\n    for (int i = 0; i &lt; 100; i++) {\n        ints[i] = random();\n    }\n\n    printf(\"ptr: %d\\n\", *local_var_ptr);\n\n    return 0;\n}\n</code></pre> <pre><code>./main\nptr: 69\nptr: 69\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n\nstatic int count = 10;\n\nvoid func(void) {\n    static int i = 5;\n    i++;\n    printf(\"i is %d and count is %d\\n\", i, count);\n}\n\nint main(void) {\n    while (count--) {\n        func();\n    }\n\n    return 0;\n}\n</code></pre> <pre><code>./main\ni is 6 and count is 9\ni is 7 and count is 8\ni is 8 and count is 7\ni is 9 and count is 6\ni is 10 and count is 5\ni is 11 and count is 4\ni is 12 and count is 3\ni is 13 and count is 2\ni is 14 and count is 1\ni is 15 and count is 0\n</code></pre>"},{"location":"c/#extern-external-linkage","title":"<code>extern</code> (External Linkage)","text":"<p>The <code>extern</code> storage class is used to give a reference of a global variable that is visible to ALL the program files. When you use <code>extern</code> the variable cannot be initialized as all it does is point the variable name at a storage location that has been previously defined.</p> <p>Inforamtion</p> <p>When global variables (or functions) are declared, unless specified, they are classified with external linkage.</p> main.csupport.cOutput <pre><code>#include &lt;stdio.h&gt;\n\nint count;\nextern void write_extern();\n\nint main() {\n   count = 5;\n   write_extern();\n   return 0;\n}\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n\nextern int count;\n\nvoid write_extern(void) {\n    printf(\"count is %d\\n\", count);\n}\n</code></pre> <pre><code>&gt; gcc support.c main.c -o main\n&gt; ./main\n5\n</code></pre>"},{"location":"c/#register","title":"<code>register</code>","text":"<p><code>register</code> keyword is used to suggest the compiler to put the variable in a CPU register. Since CPU registers is the fastest memory (and very scarce in quantity), it is recommended to be reserved for variables that are very frequently accessed.</p> <p>Tip</p> <p>Read this to know about global register variables.</p> <p>Important</p> <p><code>register</code> keyword merely reports a suggestion to the compiler; the compiler is within its legal rights to just ignore it if deemed unnecessary.</p> <p>Note</p> <p><code>register</code> variables don't have memory addresses since they are not in memory, so you are prohibited from using the <code>&amp;</code> operator on such variables.</p> How to Register Variables<pre><code>register int name;\n</code></pre>"},{"location":"c/#inline-functions","title":"Inline Functions","text":"<p><code>inline</code> specifier hints the compiler to put the body of a function in its parent scope when it is called; thus avoiding placing data on a new stack frame and retrieving its data. It is merely a hint, the compiler is free to do what is best for actual performance gains.</p> <p>Tip</p> <p>Read more about inline functions here.</p> <p>A <code>static inline</code> function can be declared and defined with no restrictions, but there are restrictions for non-static inline functions. Read the citation in the tip for more information.</p>"},{"location":"c/#structs-unions-and-enums","title":"Structs, Unions, and Enums","text":"<p>A <code>struct</code> is also a collection of data items, except with a <code>struct</code> the data items can have different data types, and the individual fields within the <code>struct</code> are accessed by name instead of an integer index.</p> <p>Tip</p> <p>Visit this page for more information.</p>"},{"location":"c/#tagged-structs","title":"Tagged Structs","text":"<p><pre><code>struct Part {\n    int number, on_hand;\n    char name [ NAME_LEN + 1 ];\n    double price;\n};\n</code></pre> The tag is <code>Part</code> in the above example, fields being its members. <code>struct Part</code> is now a valid data type.</p> <p>It is possible to simultaneously declare variables with the following syntax: <pre><code>struct Student {\n    int nClasses;\n    char name [ NAME_LEN + 1 ];\n    double gpa; \n} joe, sue, mary;\n</code></pre></p>"},{"location":"c/#anonymous-structs","title":"Anonymous Structs","text":"<p><pre><code>struct {\n    int nClasses;\n    char name [ NAME_LEN + 1 ];\n    double gpa; \n} alice, bill;\n</code></pre> Since there is no tag, there is no data type for this <code>struct</code>.</p>"},{"location":"c/#struct-bit-fields","title":"Struct Bit Fields","text":"<p>To properly understand the usage of bit fields one needs very low-level knowledge of how computers work, how data-types are stored in memory, etc. However for a general introduction, check this.</p>"},{"location":"c/#unions","title":"Unions","text":"<p>Unions are declared, created, and used exactly the same as structs, except for one key difference:</p> <ul> <li>Structs allocate enough space to store all of the fields in the struct. The first one is stored at the beginning of the struct, the second is stored after that, and so on.</li> <li>Unions only allocate enough space to store the largest field listed, and all fields are stored at the same space - the beginnion of the union.</li> </ul> <p>Important</p> <p>All fields in a union share the same space, which can be used for any listed field but not more than one of them.</p> <p>In order to know which union field is actually stored, unions are often nested inside of structs, with an enumerated type indicating what is actually stored there.</p> <pre><code>typedef struct Flight {\n    enum { PASSENGER, CARGO } type;\n    union {\n        int npassengers;\n        double tonnages;\n    } cargo;\n} Flight;\n\nFlight flights[1000];\n\nflights[42].type = PASSENGER;\nflights[42].cargo.npassengers = 150;\n\nflights[20].type = CARGO;\nflights[20].cargo.tonnages = 356.78;\n</code></pre>"},{"location":"c/#enums","title":"Enums","text":"<p>Enumerated data types are a special form of integers with the following constraints: - Only certain pre-determined values are allowed. - Each valid value is assigned a name, which is then normally used instead of integer values when working with this data type.</p> <p><pre><code>enum suits { CLUBS, HEARTS, SPADES, DIAMONDS, NOTRUMP } trump;\nenum suits ew_bid, ns_bid;\n\ntypedef enum Direction { NORTH, SOUTH, EAST, WEST } Direction;\n\nDirection next_move = NORTH;\n</code></pre> Values may be assigned to specific enum value names. - Any names without assigned values will get one higher than the previous entry. - If the first name does not have an assigned value, it gets the value of zero. - It is even legal to assign the same value to more than one name.</p> <pre><code>enum Errors {\n    NONE=0, MINOR1=100, MINOR2, MINOR3,\n    MAJOR1=1000, MAJOR2, DIVIDE_BY_ZERO=1000\n};\n</code></pre>"}]}